const withBundleAnalyzer = require("@next/bundle-analyzer")({
    enabled: process.env.ANALYZE === "true",
});
const withWorkbox = require("next-with-workbox");
const withSitemap = require("next-with-sitemap");
const { ProvidePlugin } = require("webpack");
// const FaviconsManifestWebpackPlugin = require("@anolilab/favicons-manifest-webpack-plugin")

const path = require("path");
const nextConfig = require("./anolilab.config.cjs");
const packageJson = require('./package.json');

const dependencies = Object.keys({...packageJson.dependencies, ...packageJson.devDependencies });

const traverse = (rules) => {
    for (let rule of rules) {
        if (typeof rule.loader === "string" && rule.loader.includes("css-loader")) {
            if (rule.options && rule.options.modules && typeof rule.options.modules.getLocalIdent === "function") {
                let nextGetLocalIdent = rule.options.modules.getLocalIdent;

                rule.options.modules.getLocalIdent = (context, _, exportName, options) => {
                    if (dependencies.includes('@linaria/webpack-loader')) {
                        if (context.resourcePath.includes(nextConfig.linaria.extension)) {
                            return exportName;
                        }
                    }

                    return nextGetLocalIdent(context, _, exportName, options);
                };
            }
        }

        if (typeof rule.use === "object") {
            traverse(Array.isArray(rule.use) ? rule.use : [rule.use]);
        }

        if (Array.isArray(rule.oneOf)) {
            traverse(rule.oneOf);
        }
    }
};

const isCssRules = (rule) => {
    if (!rule.test) {
        return false;
    }

    if (Array.isArray(rule.test)) {
        let has = false;

        rule.test.forEach((r) => {
            nextConfig.css.extensions.includes(r.toString());
        });

        return has;
    }

    return nextConfig.css.extensions.includes(rule.test);
};

let webpackConfig = {
    poweredByHeader: false,
    experimental: {
        modern: true,
        css: true,
        polyfillsOptimization: true,
        optimizeFonts: true,
        optimizeImages: true,
        productionBrowserSourceMaps: true,
        strictPostcssConfiguration: true
    },

    pageExtensions: nextConfig.pageExtensions,

    i18n: nextConfig.i18n,

    async headers()  {
        return [
            {
                source: '/(.*)',
                headers: nextConfig.securityHeaders
            }
        ];
    },

    webpack(config, options) {
        const { dev, isServer } = options;

        const typingLoader = {
            loader: "@teamsupercell/typings-for-css-modules-loader",
            options: {
                banner: "// This file is automatically generated from your CSS. Any edits will be overwritten.",
                disableLocalsExport: true,
                verifyOnly: !dev,
                prettierConfigFile: path.resolve(__dirname, ".prettierrc.js"),
            },
        };

        config.module.rules.find((rule) => {
            if (Array.isArray(rule.oneOf)) {
                rule.oneOf.forEach((statement) => {
                    if (!isCssRules(statement)) {
                        return;
                    }

                    const index = statement.use.findIndex(({ loader }) => loader.match(/\/css-loader\//));

                    if (index > -1) {
                        statement.use.splice(index, 0, typingLoader);
                    }
                    // If we didn't find a css-loader we can push the typingLoader onto the use statement
                    else {
                        statement.use.push(typingLoader);
                    }
                });
            }
        });

        const aliases = config.resolve.alias || (config.resolve.alias = {});

        aliases["rosetta"] = dev ? "rosetta/debug" : "rosetta";

        traverse(config.module.rules);

        if (dependencies.includes('@linaria/webpack-loader')) {
            config.module.rules.push({
                test: /\.(tsx|ts|js|mjs|jsx)$/,
                exclude: /node_modules/,
                use: [
                    {
                        loader: require.resolve("@linaria/webpack-loader"),
                        options: {
                            sourceMap: process.env.NODE_ENV !== "production",
                            ...nextConfig.linaria,
                        },
                    },
                ],
            });
        }

        if (process.env.ANALYZE_BUILD) {
            const { BundleAnalyzerPlugin } = require("webpack-bundle-analyzer");

            config.plugins.push(
                new BundleAnalyzerPlugin({
                    analyzerMode: "server",
                    analyzerPort: isServer ? 8888 : 8889,
                    openAnalyzer: true,
                }),
            );
        }

        // config.plugins.push(
        //     new FaviconsManifestWebpackPlugin({
        //         logo: path.resolve(__dirname, 'public', 'favicon.svg')
        //     })
        // );

        config.plugins.push(
            new ProvidePlugin(nextConfig.provide),
        );

        return config;
    },
};

if (nextConfig.images  !== undefined) {
    webpackConfig.images = nextConfig.images;
}

if (nextConfig.env !== undefined) {
    webpackConfig.env = nextConfig.env;
}

webpackConfig = withBundleAnalyzer(webpackConfig);
webpackConfig = withWorkbox({ workbox: {}, ...webpackConfig });

if (nextConfig.sitemap.active) {
    webpackConfig = withSitemap({
        sitemap: {
            baseUrl: nextConfig.domain,
            alternateBaseUrls: nextConfig.i18n.domains.map((domain) => ({
                lang: domain.defaultLocale,
                url: domain.domain,
            })),
            dest: nextConfig.sitemap.dest,
            pages: nextConfig.sitemap.pages,
            pageTags: nextConfig.sitemap.pageTags,
            robots: nextConfig.sitemap.robots,
            sitemap: true,
        },
        ...webpackConfig,
    });
}

module.exports = webpackConfig;
