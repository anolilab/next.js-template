const withPreact = require("next-plugin-preact");
const withBundleAnalyzer = require("@next/bundle-analyzer")({
    enabled: process.env.ANALYZE === "true",
});
const withWorkbox = require("next-with-workbox");
const withSitemap = require("next-with-sitemap");
const { ESBuildPlugin, ESBuildMinifyPlugin } = require("esbuild-loader");
const { ProvidePlugin } = require("webpack");
// const FaviconsManifestWebpackPlugin = require("@anolilab/favicons-manifest-webpack-plugin")

const path = require("path");
const nextConfig = require("./anolilab.config.cjs");
const tsconfig = require("./tsconfig.json");

const traverse = (rules) => {
    for (let rule of rules) {
        if (typeof rule.loader === "string" && rule.loader.includes("css-loader")) {
            if (rule.options && rule.options.modules && typeof rule.options.modules.getLocalIdent === "function") {
                let nextGetLocalIdent = rule.options.modules.getLocalIdent;

                rule.options.modules.getLocalIdent = (context, _, exportName, options) => {
                    if (context.resourcePath.includes(nextConfig.linaria.extension)) {
                        return exportName;
                    }

                    return nextGetLocalIdent(context, _, exportName, options);
                };
            }
        }

        if (typeof rule.use === "object") {
            traverse(Array.isArray(rule.use) ? rule.use : [rule.use]);
        }

        if (Array.isArray(rule.oneOf)) {
            traverse(rule.oneOf);
        }
    }
};

const isCssRules = (rule) => {
    if (!rule.test) {
        return false;
    }

    if (Array.isArray(rule.test)) {
        let has = false;

        rule.test.forEach((r) => {
            nextConfig.css.extensions.includes(r.toString());
        });

        return has;
    }

    return nextConfig.css.extensions.includes(rule.test);
};

function useEsbuildMinify(config, options) {
    const terserIndex = config.optimization.minimizer.findIndex(
        (minimizer) => minimizer.constructor.name === "TerserPlugin",
    );

    if (terserIndex > -1) {
        config.optimization.minimizer.splice(terserIndex, 1, new ESBuildMinifyPlugin(options));
    }
}

function useEsbuildLoader(config, options) {
    const jsLoader = config.module.rules.find((rule) => rule.test && rule.test.test(".tsx"));

    if (jsLoader) {
        jsLoader.use.loader = "esbuild-loader";
        jsLoader.use.options = options;
    }
}

let webpackConfig = {
    poweredByHeader: false,
    experimental: {
        modern: true,
        css: true,
        polyfillsOptimization: true,
        optimizeFonts: true,
        optimizeImages: true,
        productionBrowserSourceMaps: true,
        strictPostcssConfiguration: true
    },
    future: {
        webpack5: true,
    },

    pageExtensions: nextConfig.pageExtensions,

    i18n: nextConfig.i18n,

    async headers()  {
        return [
            {
                source: '/(.*)',
                headers: nextConfig.securityHeaders
            }
        ];
    },

    webpack(config, options) {
        const { dev, isServer } = options;

        const typingLoader = {
            loader: "@teamsupercell/typings-for-css-modules-loader",
            options: {
                banner: "// This file is automatically generated from your CSS. Any edits will be overwritten.",
                disableLocalsExport: true,
                verifyOnly: !dev,
                prettierConfigFile: path.resolve(__dirname, ".prettierrc.js"),
            },
        };

        config.module.rules.find((rule) => {
            if (Array.isArray(rule.oneOf)) {
                rule.oneOf.forEach((statement) => {
                    if (!isCssRules(statement)) {
                        return;
                    }

                    const index = statement.use.findIndex(({ loader }) => loader.match(/\/css-loader\//));

                    if (index > -1) {
                        statement.use.splice(index, 0, typingLoader);
                    }
                    // If we didn't find a css-loader we can push the typingLoader onto the use statement
                    else {
                        statement.use.push(typingLoader);
                    }
                });
            }
        });

        const aliases = config.resolve.alias || (config.resolve.alias = {});

        aliases["rosetta"] = dev ? "rosetta/debug" : "rosetta";

        traverse(config.module.rules);

        config.module.rules.push({
            test: /\.(tsx|ts|js|mjs|jsx)$/,
            exclude: /node_modules/,
            use: [
                {
                    loader: require.resolve("@linaria/webpack-loader"),
                    options: {
                        sourceMap: process.env.NODE_ENV !== "production",
                        ...nextConfig.linaria,
                    },
                },
            ],
        });

        if (process.env.ANALYZE_BUILD) {
            const { BundleAnalyzerPlugin } = require("webpack-bundle-analyzer");

            config.plugins.push(
                new BundleAnalyzerPlugin({
                    analyzerMode: "server",
                    analyzerPort: isServer ? 8888 : 8889,
                    openAnalyzer: true,
                }),
            );
        }

        // config.plugins.push(
        //     new FaviconsManifestWebpackPlugin({
        //         logo: path.resolve(__dirname, 'public', 'favicon.svg')
        //     })
        // );

        config.plugins.push(
            new ProvidePlugin(nextConfig.provide),
        );

        // config.plugins.push(new ESBuildPlugin())
        // useEsbuildMinify(config, {
        //     target: tsconfig.compilerOptions.target.toLowerCase(),
        //     css: true,
        // });
        // useEsbuildLoader(config, {
        //     loader: "tsx",
        //     target: tsconfig.compilerOptions.target.toLowerCase(),
        //     jsxFactory: tsconfig.compilerOptions.jsxFactory,
        //     jsxFragment: tsconfig.compilerOptions.jsxFragmentFactory,
        //     tsconfigRaw: tsconfig,
        // });

        return config;
    },
};

if (nextConfig.images  !== undefined) {
    webpackConfig.images = nextConfig.images;
}

if (nextConfig.env !== undefined) {
    webpackConfig.env = nextConfig.env;
}

webpackConfig = withPreact(webpackConfig);
webpackConfig = withBundleAnalyzer(webpackConfig);
webpackConfig = withWorkbox({ workbox: {}, ...webpackConfig });

if (nextConfig.sitemap.active) {
    webpackConfig = withSitemap({
        sitemap: {
            baseUrl: nextConfig.domain,
            alternateBaseUrls: nextConfig.i18n.domains.map((domain) => ({
                lang: domain.defaultLocale,
                url: domain.domain,
            })),
            dest: nextConfig.sitemap.dest,
            pages: nextConfig.sitemap.pages,
            pageTags: nextConfig.sitemap.pageTags,
            robots: nextConfig.sitemap.robots,
            sitemap: true,
        },
        ...webpackConfig,
    });
}

module.exports = webpackConfig;
